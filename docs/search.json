[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Teal 101",
    "section": "",
    "text": "Github\n  \n\n  \n  \nThis is the unofficial guide for the teal app.\nFor official documentation, please refer to insightengineering and pharmaverse\nAny feedback / mistake corrections are welcome, you can find me here."
  },
  {
    "objectID": "test_shinylive_embed.html",
    "href": "test_shinylive_embed.html",
    "title": "test shinylive",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "test_shinylive_embed.html#quarto",
    "href": "test_shinylive_embed.html#quarto",
    "title": "test shinylive",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "test_shinylive_embed.html#running-code",
    "href": "test_shinylive_embed.html#running-code",
    "title": "test shinylive",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\nlibrary(shiny)\nui &lt;- fluidPage(\n  titlePanel(\"Hello Shiny!\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\n        inputId = \"bins\",\n        label = \"Number of bins:\",\n        min = 1,\n        max = 50,\n        value = 30\n      )\n    ),\n    mainPanel(\n      plotOutput(outputId = \"distPlot\")\n    )\n  )\n)\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlot({\n    x &lt;- faithful$waiting\n    bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n    hist(x,\n      breaks = bins, col = \"#75AADB\", border = \"white\",\n      xlab = \"Waiting time to next eruption (in mins)\",\n      main = \"Histogram of waiting times\"\n    )\n  })\n}\nshinyApp(ui = ui, server = server)\nWhat aboout teal app?\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n\nlibrary(dplyr)\nlibrary(teal.modules.general)\nlibrary(teal.modules.clinical)\n\n# data ----\n# Prepare data object\n# ? what does default_cdisc_join_keys do?\ndata &lt;- teal_data()\ndata &lt;- within(data, {\n  ADSL &lt;- rADSL\n})\njoin_keys(data) &lt;- default_cdisc_join_keys[\"ADSL\"]\n\n\n# define inputs ----\n# Prepare module inputs\n# this step is not strictly necessary, since only one dataset is involved\nADSL &lt;- data[[\"ADSL\"]]\n\n\n# choices_selected is from teal.transform\n# define arm \n# ARMCD: arm code (a, b, c)\n# ARM: arm name (drug, placebo, combination)\n# (probably always fixed)\ncs_arm_var &lt;- choices_selected(\n  choices = variable_choices(ADSL, subset = c(\"ARMCD\", \"ARM\")),\n  selected = \"ARM\"\n)\n\n\n# demographic variables\n# selected the numeric and factor variables\n# i.e. date, dttm, chr are excluded\ndemog_vars_adsl &lt;- ADSL |&gt;\n  select(where(is.numeric) | where(is.factor)) |&gt;\nADSL |&gt;\n  select(!(where(is.numeric) | where(is.factor))) |&gt;\n  names()\n\n# tm_data_table -----\nmod_dt &lt;- tm_data_table(\"Data Table\")\n\n\n# tm_t_summary -----\nmod_summary &lt;- tm_t_summary(\n  label = \"Demographic Table\",\n  \n  # add which dataset to use\n  dataname = \"ADSL\",\n  arm_var = cs_arm_var,\n  summarize_vars = choices_selected(\n    choices = variable_choices(ADSL, demog_vars_adsl),\n    selected = c(\"SEX\", \"AGE\", \"RACE\")\n  )\n)\n\n\n# _______ -----\n# Create app -----\napp &lt;- init(\n  # single data source: adsl\n  data = data,\n  modules = list(\n\n    # module 1, display data\n    mod_dt,\n\n    # module 2, summary table\n    mod_summary,\n  )\n  # for medical history: use data 2\n  # data = data2,\n  #module = mod_mh\n\n)\n\nif (Sys.getenv(\"QUARTO_ROOT\") == \"\") {\n  shinyApp(app$ui, app$server)\n}"
  },
  {
    "objectID": "ex1_shinylive.html",
    "href": "ex1_shinylive.html",
    "title": "Exercise 1",
    "section": "",
    "text": "Example\nUsing iris and mtcars datasets.\n\n# load teal and all dependent packages\nlibrary(teal)\n\n# create empty `teal_data` object\ndata &lt;- teal_data()\n\n# execute code within it\ndata &lt;- within(data, {\n  IRIS &lt;- iris\n  MTCARS &lt;- mtcars\n})\n\napp &lt;- init(\n  data = data,\n  modules = list(\n    example_module()\n  )\n)\n\nif (Sys.getenv(\"QUARTO_ROOT\") == \"\") {\n  shinyApp(app$ui, app$server)\n}\n\n\n\nApp"
  },
  {
    "objectID": "ex2_shinylive.html",
    "href": "ex2_shinylive.html",
    "title": "Exercise 2",
    "section": "",
    "text": "library(dplyr)\nlibrary(teal.modules.general)\nlibrary(teal.modules.clinical)\nlibrary(teal)\n\napp &lt;- init(\n  # add data\n  data = teal_data(iris = iris),\n  \n  # add modules (as a list)\n  modules = list(\n    module(\n      label = \"iris histogram\",\n      \n      # server\n      server = function(input, output, session, data) {\n        \n        \n        updateSelectInput(session = session,\n                          inputId =  \"var\",\n                          choices = names(data()[[\"iris\"]])[1:4])\n        \n        # plot\n        output$hist &lt;- renderPlot({\n          req(input$var)\n          hist(\n            x = data()[[\"iris\"]][[input$var]],\n            main = sprintf(\"Histogram of %s\", input$var),\n            xlab = input$var\n          )\n        })\n      },\n      \n      # ui\n      ui = function(id) {\n        ns &lt;- NS(id)\n        list(\n          selectInput(inputId = ns(\"var\"),\n                      label =  \"Column name\",\n                      choices = NULL),\n          plotOutput(outputId = ns(\"hist\"))\n        )\n      }\n    )\n  )\n)\n\nif (Sys.getenv(\"QUARTO_ROOT\") == \"\") {\n  shinyApp(app$ui, app$server)\n}\n\n# shinyApp(app$ui, app$server)\n\n\nApp"
  },
  {
    "objectID": "ex_clinical.html",
    "href": "ex_clinical.html",
    "title": "Exercise 2",
    "section": "",
    "text": "library(dplyr)\nlibrary(teal)\nlibrary(teal.modules.general)\nlibrary(teal.modules.clinical)\n\n# data ----\n# Prepare data object\n# ? what does default_cdisc_join_keys do?\ndata &lt;- teal_data()\ndata &lt;- within(data, {\n  ADSL &lt;- rADSL\n})\njoin_keys(data) &lt;- default_cdisc_join_keys[\"ADSL\"]\n\n\n# define inputs ----\n# Prepare module inputs\n# this step is not strictly necessary, since only one dataset is involved\nADSL &lt;- data[[\"ADSL\"]]\n\n\n# choices_selected is from teal.transform\n# define arm \n# ARMCD: arm code (a, b, c)\n# ARM: arm name (drug, placebo, combination)\n# (probably always fixed)\ncs_arm_var &lt;- choices_selected(\n  choices = variable_choices(ADSL, subset = c(\"ARMCD\", \"ARM\")),\n  selected = \"ARM\"\n)\n\n\n# demographic variables\n# selected the numeric and factor variables\n# i.e. date, dttm, chr are excluded\ndemog_vars_adsl &lt;- ADSL |&gt;\n  select(where(is.numeric) | where(is.factor)) |&gt;\n  names()\n\n\n\n# these are the excluded ones (study ID, subject ID, ...)\n# ADSL |&gt;\n#   select(!(where(is.numeric) | where(is.factor))) |&gt;\n#   names()\n\n\n# tm_data_table -----\nmod_dt &lt;- tm_data_table(\"Data Table\")\n\n\n# tm_t_summary -----\nmod_summary &lt;- tm_t_summary(\n  label = \"Demographic Table\",\n  \n  # add which dataset to use\n  dataname = \"ADSL\",\n  arm_var = cs_arm_var,\n  summarize_vars = choices_selected(\n    choices = variable_choices(ADSL, demog_vars_adsl),\n    selected = c(\"SEX\", \"AGE\", \"RACE\")\n  )\n)\n\n\n# _______ -----\n# Create app -----\napp &lt;- init(\n  # single data source: adsl\n  data = data,\n  modules = list(\n    \n    # module 1, display data\n    mod_dt,\n    \n    # module 2, summary table\n    mod_summary\n  )\n  # for medical history: use data 2\n  # data = data2,\n  #module = mod_mh\n  \n)\n\nif (Sys.getenv(\"QUARTO_ROOT\") == \"\") {\n  shinyApp(app$ui, app$server)\n}\n\n# shinyApp(app$ui, app$server)\n\n\nApp"
  },
  {
    "objectID": "nest/index.html",
    "href": "nest/index.html",
    "title": "Catalog",
    "section": "",
    "text": "This page lists topics that are related to shiny and teal."
  },
  {
    "objectID": "nest/index.html#shiny",
    "href": "nest/index.html#shiny",
    "title": "Catalog",
    "section": "Shiny",
    "text": "Shiny\n\n\n\n\n\n\nTitle\n\n\n\n\n\n\n\n\nShiny and shiny modules\n\n\n\n\n\n\nShiny reactivity\n\n\n\n\n\n\nUI topics\n\n\n\n\n\n\nShinylive extension to Quarto website\n\n\n\n\n\n\nShiny workflow\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "nest/index.html#teal",
    "href": "nest/index.html#teal",
    "title": "Catalog",
    "section": "Teal",
    "text": "Teal\n\n\n\n\n\n\nTitle\n\n\n\n\n\n\n\n\nTeal 101\n\n\n\n\n\n\nTeal custom modules\n\n\n\n\n\n\nTeal workshop preparation\n\n\n\n\n\n\nplotly modules - part 1\n\n\n\n\n\n\nplotly modules - part 2: selection events\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "nest/teal_101.html",
    "href": "nest/teal_101.html",
    "title": "Teal 101",
    "section": "",
    "text": "Getting started with Teal\nTeal workshop PHUSE CSS 2025\nTeal gallery: sample apps based on teal framework\nTeal technical blueprint\nVideo: a complete guide to getting started with teal. This video breaks down the components in a teal app, very useful"
  },
  {
    "objectID": "nest/teal_101.html#running-my-first-app",
    "href": "nest/teal_101.html#running-my-first-app",
    "title": "Teal 101",
    "section": "Running my first app",
    "text": "Running my first app\nMandatory arguments: data, module\nLoads:\n\nshiny\nteal.data\nteal.code\nteal.slice\n\nMain panel (Active Module Content)):\n\nshows two modules that loads IRIS data\ncan have multiple\n\nSide (right) (Filter Panel):\n\nactive filter summary: number of observations\nactive filter variables\n\n\nTeal packages\n\nteal.data: defines data of teal app\nteal.slice: defines data filtering before passing into modules\n\nAnd others"
  },
  {
    "objectID": "nest/teal_101.html#creating-a-teal-app",
    "href": "nest/teal_101.html#creating-a-teal-app",
    "title": "Teal 101",
    "section": "Creating a teal app",
    "text": "Creating a teal app\nThe bare bone structure is like this below:\n\nlibrary(teal)\n\napp &lt;- init(\n    data = data, \n    modules = modules)\n\nshinyApp(ui = app$ui, server = app$server)\n\nData\n\nInput: data.frame, cdisc data format data.frame, multi-asset objects\nteal_data(), if data is common across modules\nteal_data_module() if data is different\n\nModules\n\nteal.modules.general(): data.frame\nteal.modules.clinical(): cdisc data\nteal.modules.hermes(): multi-asset objects (check out TLG.catelog, biomarker.catelog)\n\n\nPart 1: teal_data()\nCreates an S4 object, &lt;teal_data&gt;\nSlots: env, datanames, code, verified, join_keys (only useful for cdisc)\nMethods: â€¦\n\n# create a single data object \ndata &lt;- teal_data(\n  MTCARS = head(mtcars)\n)"
  },
  {
    "objectID": "nest/teal_101.html#pharmaverse",
    "href": "nest/teal_101.html#pharmaverse",
    "title": "Teal 101",
    "section": "Pharmaverse",
    "text": "Pharmaverse\nHow does teal fit in the pharmaverse ecosystem? (Examples)\n\nSDTM\n\n\nADaM\n\n\nTLG\nCalculation and analysis\n\ntern: analysis functions for tables and graphs in clinical trial reporting\nosprey:\ngoshawk\nhermes\n\n\n\nInteractive (teal)\nCalculations above link to the teal modules to add interactivity. In addition to teal.moduels.general, we have\n\ntern -&gt; teal.modules.clinical\nosprey -&gt; teal.osprey\ngoshawk -&gt; teal.goshawk\nhermes -&gt; teal.modules.hermes"
  },
  {
    "objectID": "nest/shiny_101.html",
    "href": "nest/shiny_101.html",
    "title": "Shiny and shiny modules",
    "section": "",
    "text": "Some new technology related to shiny"
  },
  {
    "objectID": "nest/shiny_101.html#get-started",
    "href": "nest/shiny_101.html#get-started",
    "title": "Shiny and shiny modules",
    "section": "Get started",
    "text": "Get started\nIn an empty R script, type shiny, then a snippet should pop up to provide you with a template that contains to key components.\nTips\n\nrun the entire script\n\nAnatomy of a standard shiny app: 3 components\n\nui function\nserver function\nshinyApp function that combines the two parts above\n\n\n# load the package\nlibrary(shiny)\n\n# ui\nui &lt;- page_fluid()\n\n# server\nserver &lt;- function(input, output, session){}\n\n# combines the two\nshinyApp(ui = ui, server = server)\n# shinyApp(ui = app$ui, server = app$server)\n\nServer functions\n\ninside ui, we have defined variables with inputID = x, outputID = 'scatterplot'; in the server these are called upon\nobjects to be displayed should be saved to outputs$\ninput values should be referred to with inputs$\nreactive objects should be built with render*() functions (renderPlot, renderText, renderTable etc)"
  },
  {
    "objectID": "nest/shiny_101.html#modules",
    "href": "nest/shiny_101.html#modules",
    "title": "Shiny and shiny modules",
    "section": "Modules",
    "text": "Modules\nMake the code more organized. Essentially wrapping components of UI / server into functions, then call the functions in the app.\n\nVery useful tutorial by Jonas Hagenberg: Structure your app: introduction to Shiny modules\n(More advanced) Talk by Eric Nantz: Effective use of Shiny modules in application development\n\nCareful design: what does the module do? what is it trying to accomplish?\nInput and return values: static or reactive inputs? complexity of return values; which outputs serve as inputs for other modules?\n\nModule structure\nThis is how the shiny app with modules look like\n\n# ui\nui &lt;- page_fluid(\n  \n  # other UI elements\n  # ...\n  #\n  # module UI\n  module_UI(id = 'id_1')\n  # can have more than one\n)\n\n# server\nserver &lt;- function(input, output, session){\n  \n  # other server part\n  # ...\n  # module \n  module_server(id = 'id_1')\n  # can have more than one\n}\n\n# combines the two\nshinyApp(ui = ui, server = server)\n\nDefine the modules\n\n# define the UI part\nmodule_UI &lt;- function(id){\n  \n  # namespaced id for input and output\n  ns &lt;- NS(id)\n  \n  # this is just a fancy list\n  tagList(\n    # your UI elements\n  )\n}\n\n# define the server part\nmodule_server &lt;- function(id){\n  moduleServer(\n    id, \n    function(input, output, session){\n      \n    }\n  )\n}"
  },
  {
    "objectID": "nest/shiny_101.html#serverless-shiny",
    "href": "nest/shiny_101.html#serverless-shiny",
    "title": "Shiny and shiny modules",
    "section": "Serverless shiny",
    "text": "Serverless shiny\nMaking use of webR\nshinylive::export(from_here, to_there)\nUse GHA to deploy the app\nPublic! No secrets"
  },
  {
    "objectID": "nest/shiny_reactivity.html",
    "href": "nest/shiny_reactivity.html",
    "title": "Shiny reactivity",
    "section": "",
    "text": "Key idea: specify a graph of dependencies, so that when an input changes, all related output are updated automatically.\nUsual way in R: procedural. You tell what to do and when. Imperative programming\nn &lt;- 1\nresult &lt;- 1 + n\nn &lt;- 2\nresult &lt;- 1 + n\nReactive programming: define how to do something; when the right condition meets. Declarative programming\nresult &lt;- reactive({\n  1 + input$n\n})"
  },
  {
    "objectID": "nest/shiny_reactivity.html#reactivity",
    "href": "nest/shiny_reactivity.html#reactivity",
    "title": "Shiny reactivity",
    "section": "Reactivity",
    "text": "Reactivity\n\nui &lt;- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$greeting &lt;- renderText({\n    paste0(\"Hello \", input$name, \"!\")\n  })\n}\n\nRun the app\nEvery time the input$name changes, the output also changes. The reactivity simply means that every time a user updates the browser input, the developer does not need to re-run the program. The output is automatically updated by itself.\nMy understanding: the developer only needs to develop the reactive code, then leaves everything to the user. The program reacts to the input\n\nOrder of execution\nReactive graph: describes how inputs and outputs are connected.\n\n\nReactive context\nReactive values can only be used inside reactive contexts. Access reactive values outside reactive context will lead to an error. E.g.\n\nserver &lt;- function(input, output){\n  print(input$num)\n}\n# this results in an error, as 'print' is not a reactive context\n\n\nAny render*() is a reactive context\nUse observe({...}) access reactive variable: it is a reactive context\n\n\n# this is the correct way to print\nserver &lt;- function(input, output){\n  observe({ \n    print(input$num) # put in the reactive context\n  })\n  \n}\n\n\n\nReactive expressions / variables\nCan create a reactive variable using reactive({}), which is a reactive context.\nThe order of these two lines below doesnâ€™t matter.\n\nserver &lt;- function(input, output, session) {\n  \n  # define a reactive expression here\n  string &lt;- reactive(paste0(\"Hello \", input$name, \"!\"))\n  # can not simply do the line below:\n  # paste0(\"Hello \", input$name, \"!\")\n  \n  # call it \n  output$greeting &lt;- renderText(string())\n}\n\nAccess custom reactive variables like a function: need the (). For example, call string() rather than string.\n\nserver &lt;- function(input, output){\n  # create a reactive variable\n  x &lt;- reactive({\n    input$num + 1\n  })  \n\n  observe({\n    print(input$num)\n    print(x()) # with ()\n  })\n}\n\n\n\nObserve, observeEvent\nshiny::observe creates observer. It updates inputâ€™s value. Does not have a return value. It gets executed when the reactive values (e.g.Â input$value) it depends on changes.\nCommon use: updateSelectInput, updateSliderInput, updateTextInput to change the input value.\n\n# example from custom module\nshiny::observe({\n  shiny::updateSelectInput( \n    session,\n    \"dataset\",\n    choices = names(data())\n  )\n})\n\nThis observe block runs every time input data changes.\nshiny::observeEvent is a special case of observe. It only focuses on one specific change. That is why it has an additional argument, eventExpr, which specifies the event to listen to.\n\n# specify what to watch\nobserveEvent(input$dataset, { \n  req(input$dataset) \n  numeric_vars &lt;- names(data()[[input$dataset]])[sapply(data()[[input$dataset]], is.numeric)]\n  shiny::updateSelectInput(\n    session,  \n    \"variable\", \n    choices = numeric_vars)\n})"
  },
  {
    "objectID": "nest/teal_custom.html",
    "href": "nest/teal_custom.html",
    "title": "Teal custom modules",
    "section": "",
    "text": "The technology underneath is shiny modules.\nThere are 4 steps:"
  },
  {
    "objectID": "nest/teal_custom.html#ui-part",
    "href": "nest/teal_custom.html#ui-part",
    "title": "Teal custom modules",
    "section": "UI part",
    "text": "UI part\nTwo things to provide: data and variable.\n\nlibrary(teal)\n\n# UI function for the custom histogram module\nhistogram_module_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::selectInput(\n      ns(\"dataset\"),\n      \"Select Dataset\",\n      choices = c(\"iris\", \"mtcars\")\n    ),\n    shiny::selectInput(\n      ns(\"variable\"),\n      \"Select Variable\",\n      choices = c(names(iris), names(mtcars))\n    ),\n    shiny::plotOutput(ns(\"histogram_plot\")),\n    shiny::verbatimTextOutput(ns(\"plot_code\")) # To display the reactive plot code\n  )\n}"
  },
  {
    "objectID": "nest/teal_custom.html#server-part",
    "href": "nest/teal_custom.html#server-part",
    "title": "Teal custom modules",
    "section": "Server part",
    "text": "Server part\nRequires teal_data object.\nTo call the data, use data() - treat it as a function.\n\n# names of data: gives list of datasets inside the teal_data obj\nnames(data())\n# access specific data\ndata()[[input$dataset]] # might also just use $\n\n\n# Server function for the custom histogram module with injected variables in within()\nhistogram_module_server &lt;- function(id, data) {\n  \n  moduleServer(id, function(input, output, session) {\n   \n1    shiny::observe({\n      shiny::updateSelectInput( \n        session,\n        \"dataset\",\n        choices = names(data())\n      )\n    })\n\n2    observeEvent(input$dataset, {\n      req(input$dataset) # Ensure dataset is selected\n      numeric_vars &lt;- names(data()[[input$dataset]])[sapply(data()[[input$dataset]], is.numeric)]\n3      shiny::updateSelectInput(\n        session,  \n        \"variable\", \n        choices = numeric_vars)\n    })\n\n    \n    \n    # Create a reactive `teal_data` object with the histogram plot\n    result &lt;- reactive({\n      req(input$dataset, input$variable) # Ensure dataset and variable are selected\n\n      # Create a new teal_data object with the histogram plot\n4      new_data &lt;- within(\n        data(),\n        {\n5          my_plot &lt;- hist(\n            input_dataset[[input_vars]],\n            las = 1,\n            main = paste(\"Histogram of\", input_vars),\n            xlab = input_vars,\n            col = \"lightblue\",\n            border = \"black\"\n          )\n        },\n        \n6        input_dataset = as.name(input$dataset),\n7        input_vars = input$variable\n      )\n      new_data\n    })\n\n    # Render the histogram from the updated teal_data object\n8    output$histogram_plot &lt;- shiny::renderPlot({\n      result()[[\"my_plot\"]] \n    })\n\n    # Reactive expression to get the generated code for the plot\n    output$plot_code &lt;- shiny::renderText({\n9      teal.code::get_code(result())\n    })\n  })\n}\n\n\n1\n\nUpdate dataset choices based on available datasets in teal_data. observe is used because it needs to run every time data changes.\n\n2\n\nobserveEvent watches the changes in dataset selection. It gets updated when it changes - because different datasets have different variable names.\n\n3\n\nUpdate variable choices based on selected dataset, only including numeric variables\n\n4\n\nThis is a modified version of data(). Injected input$dataset and input$variable into within().\n\n5\n\nThis is where the function is positioned\n\n6\n\nReplace input_dataset with input$dataset\n\n7\n\nReplace input_vars with input$variable\n\n8\n\nAccess and render the plot stored in new_data\n\n9\n\nRetrieve and display the code for the updated teal_data object"
  },
  {
    "objectID": "nest/teal_custom.html#custom-module-function",
    "href": "nest/teal_custom.html#custom-module-function",
    "title": "Teal custom modules",
    "section": "Custom module function",
    "text": "Custom module function\n\ncreate_histogram_module &lt;- function(label = \"Histogram Module\") {\n1  teal::module(\n    label = label,\n    ui = histogram_module_ui,\n    server = histogram_module_server,\n2    datanames = \"all\"\n  )\n}\n\n\n1\n\nuse teal::module() to wrap the UI and server together.\n\n2\n\nthe module has access to all datasets in the teal_data object. Datasets with names starting with . are not included"
  },
  {
    "objectID": "nest/teal_custom.html#integration",
    "href": "nest/teal_custom.html#integration",
    "title": "Teal custom modules",
    "section": "Integration",
    "text": "Integration\nFinally, embed the module into your app.\n\n# Define datasets in `teal_data`\ndata_obj &lt;- teal_data(\n  iris = iris,\n  mtcars = mtcars\n)\n\n# Initialize the teal app\napp &lt;- init(\n1  data = data_obj,\n2  modules = modules(create_histogram_module())\n)\n\n# Run the app\nif (interactive()) {\n  shiny::shinyApp(ui = app$ui, server = app$server)\n}\n\n\n1\n\ncall the data object created above\n\n2\n\ncall the custom module function created above. Do not forget the ()."
  },
  {
    "objectID": "nest/shiny_reactivity.html#ns-and-ns",
    "href": "nest/shiny_reactivity.html#ns-and-ns",
    "title": "Shiny reactivity",
    "section": "NS and ns",
    "text": "NS and ns\nNamespace. NS is the function, ns is the object created by NS(id).\n\nNS takes one argument: id. It returns a function (a namespacing function).\nns &lt;- NS(id) is the standard first line of a UI module function.\nns function remembers the ID you assigned.\n\n\nns &lt;- shiny::NS(namespace = '1')\nns('my_button') # returns \"1-my_button\"\n\n[1] \"1-my_button\"\n\n\nThe purpose of having NS and namespace is to avoid ID collisions when you use the same module multiple times in a single app.\n\nui_module_ui &lt;- function(id) {\n  # 1. Create the namespacing function `ns`\n  ns &lt;- shiny::NS(id) \n\n  # 2. Use `ns` to wrap every ID\n  tagList(\n    actionButton(ns(\"my_button\"), \"Click me\"),\n    plotOutput(ns(\"my_plot\"))\n  )\n}\n\n\nui_module_ui(\"1\") will return 1-my_button, 1-my_plot\nui_module_ui('2') will return 2-my_button, 2-my_plot"
  },
  {
    "objectID": "nest/ui.html",
    "href": "nest/ui.html",
    "title": "UI topics",
    "section": "",
    "text": "These are topics that are relevant for understand how the UI is made of.\n\nlibrary(htmltools) # imported by shiny\ntagList(\n  h1(\"Title\"),\n  h2(\"Header text\"),\n  p(\"Text here\")\n)\n\nTitle\nHeader text\nText here\n\n\n\ntags$html(\n  tags$head(\n    tags$title('My first page')\n  ),\n  tags$body(\n    h1('My first heading'),\n    p('My first paragraph, with some ', strong('bold'), ' text.'),\n    div(\n      id = 'myDiv', \n      class = 'simpleDiv',\n      'Here is a div with some attributes.'\n     )\n  )\n)\n\n\n\nMy first heading\n\nMy first paragraph, with some \nbold\n text.\n\nHere is a div with some attributes."
  },
  {
    "objectID": "nest/shiny_test.html",
    "href": "nest/shiny_test.html",
    "title": "Shinylive extension to Quarto website",
    "section": "",
    "text": "Quarto extension: shinylive\nAs you may know, it is not possible to set format: shinylive in the YAML header of a quarto document when the project type is website. A good way to embed a shinylive session in a quarto website is to use webR.\nThis article documents how this is done."
  },
  {
    "objectID": "nest/shiny_test.html#example",
    "href": "nest/shiny_test.html#example",
    "title": "Shinylive extension to Quarto website",
    "section": "Example",
    "text": "Example\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n#| components: [editor, viewer]\n#| layout: vertical\nlibrary(shiny)\nui &lt;- fluidPage(\n  titlePanel(\"Hello Shiny!\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\n        inputId = \"bins\",\n        label = \"Number of bins:\",\n        min = 1,\n        max = 50,\n        value = 30\n      )\n    ),\n    mainPanel(\n      plotOutput(outputId = \"distPlot\")\n    )\n  )\n)\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlot({\n    x &lt;- faithful$waiting\n    bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n    hist(x,\n      breaks = bins, col = \"#75AADB\", border = \"white\",\n      xlab = \"Waiting time to next eruption (in mins)\",\n      main = \"Histogram of waiting times\"\n    )\n  })\n}\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "nest/shinylive_qt.html",
    "href": "nest/shinylive_qt.html",
    "title": "Shinylive extension to Quarto website",
    "section": "",
    "text": "Quarto extension: shinylive\nAs you may know, it is not possible to set format: shinylive in the YAML header of a quarto document when the project type is website. A good way to embed a shinylive session in a quarto website is to use webR.\nThis article documents how this is done."
  },
  {
    "objectID": "nest/shinylive_qt.html#example",
    "href": "nest/shinylive_qt.html#example",
    "title": "Shinylive extension to Quarto website",
    "section": "Example",
    "text": "Example\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n#| components: [editor, viewer]\n#| layout: vertical\nlibrary(shiny)\nui &lt;- fluidPage(\n  titlePanel(\"Hello Shiny!\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\n        inputId = \"bins\",\n        label = \"Number of bins:\",\n        min = 1,\n        max = 50,\n        value = 30\n      )\n    ),\n    mainPanel(\n      plotOutput(outputId = \"distPlot\")\n    )\n  )\n)\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlot({\n    x &lt;- faithful$waiting\n    bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n    hist(x,\n      breaks = bins, col = \"#75AADB\", border = \"white\",\n      xlab = \"Waiting time to next eruption (in mins)\",\n      main = \"Histogram of waiting times\"\n    )\n  })\n}\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "nest/teal_tm_t_events.html",
    "href": "nest/teal_tm_t_events.html",
    "title": "Shinylive extension to Quarto website",
    "section": "",
    "text": "(this shinylive session is disabled. Please copy paste into your own R session to execute.)\n\n##| standalone: true\n##| viewerHeight: 800\n##| components: [editor, viewer]\n##| layout: vertical\nlibrary(teal)\nlibrary(teal.modules.clinical)\n\n\ndata &lt;- teal_data()\ndata &lt;- within(data, {\n  ADSL &lt;- tmc_ex_adsl\n  ADAE &lt;- tmc_ex_adae\n})\njoin_keys(data) &lt;- default_cdisc_join_keys[names(data)]\n\nADSL &lt;- data[[\"ADSL\"]]\nADAE &lt;- data[[\"ADAE\"]]\n\napp &lt;- init(\n  data = data,\n  modules = modules(\n    tm_t_events(\n      label = \"Adverse Event Table\",\n      dataname = \"ADAE\",\n\n      # teal.transform functions\n      arm_var = choices_selected(c(\"ARM\", \"ARMCD\"), \"ARM\"),\n\n      # variable with high level term for events\n      llt = choices_selected(\n        # choices = variable_choices(ADAE, c(\"AETERM\", \"AEDECOD\")),\n        choices = c('AETERM', 'AEDECOD'),\n        selected = c(\"AEDECOD\")\n      ),\n\n      # variable with low level for events\n      hlt = choices_selected(\n        choices = variable_choices(ADAE, c(\"AEBODSYS\", \"AESOC\")),\n        selected = \"AEBODSYS\"\n      ),\n      # whether add total number of patient\n      add_total = TRUE,\n      event_type = \"adverse event\"\n    )\n  )\n)\n#if (interactive()) {\nshinyApp(app$ui, app$server)\n#}"
  },
  {
    "objectID": "nest/teal_workshop.html",
    "href": "nest/teal_workshop.html",
    "title": "Teal workshop preparation",
    "section": "",
    "text": "This is my notes on preparing the teal workshop. All the data used are simulated and public."
  },
  {
    "objectID": "nest/shiny_workflow.html",
    "href": "nest/shiny_workflow.html",
    "title": "Shiny workflow",
    "section": "",
    "text": "Development cycle (creating apps, making changes, experimenting with the results)\nSteps:\n\nwrite some code\nlaunch the app with short-cut: cmd/ctrl + shift + enter (source)\ninteractively experiment with the app\nclose app, go back to 1.\n\nCreate the app with the following lines:\n\nlibrary(shiny)\nui &lt;- fluidPage(\n)\nserver &lt;- function(input, output, session){\n}\nshinyApp(ui, server)"
  },
  {
    "objectID": "nest/teal_workshop.html#teal_data",
    "href": "nest/teal_workshop.html#teal_data",
    "title": "Teal workshop preparation",
    "section": "teal_data",
    "text": "teal_data\n\nThis is the biggest topic, 12 pages in total. Some parts need to be re-arranged for my own preference.\n\n\nGeneral usage\nWhat is teal_data?\n\nempty_teal_data &lt;- teal_data()\nclass(empty_teal_data)\n\n[1] \"teal_data\"\nattr(,\"package\")\n[1] \"teal.data\"\n\n\nGeneral usage\n\npath &lt;- 'data/cdisc/'\nADSL &lt;- read.csv(file.path(path, 'adsl.csv'))\n# create teal_data object\ndata &lt;- teal_data(\n  ADSL = ADSL\n)\n# return data object\ndata\n\nâœ– code unverified\n&lt;environment: 0x11bcc8e90&gt; ðŸ”’ \nParent: &lt;environment: package:teal.modules.clinical&gt; \nBindings:\n- ADSL: [data.frame]\n\n\nAdd another dataset, for example, ADAE\n\nADAE &lt;- read.csv(file.path(path, 'adae.csv'))\n# update teal_data object\ndata &lt;- teal_data(\n  ADSL = ADSL,\n  ADAE = ADAE\n)\ndata\n\nâœ– code unverified\n&lt;environment: 0x11a04bfd0&gt; ðŸ”’ \nParent: &lt;environment: package:teal.modules.clinical&gt; \nBindings:\n- ADAE: [data.frame]\n- ADSL: [data.frame]\n\n\n\n\nInteracting with the object\n\nnames(data)\n\n[1] \"ADAE\" \"ADSL\"\n\n\nExtract one dataset, can use either [[]] or $\n\ndata$ADSL[1:6,1:6] # only print the first 6 rows and 6 columns\n\n  STUDYID COUNTRY SITEID SUBJID      AGE SEX\n1 AB12345     CHN  CHN-1   id-1 36.94418   M\n2 AB12345     CHN CHN-11   id-2 39.82057   F\n3 AB12345     USA  USA-2   id-3 35.39604   F\n4 AB12345     RUS  RUS-1   id-4 30.54711   F\n5 AB12345     CHN CHN-11   id-5 33.16138   M\n6 AB12345     RUS  RUS-2   id-6 47.65321   F\n\ndata[['ADSL']][1:6,1:6]  # need quotation!\n\n  STUDYID COUNTRY SITEID SUBJID      AGE SEX\n1 AB12345     CHN  CHN-1   id-1 36.94418   M\n2 AB12345     CHN CHN-11   id-2 39.82057   F\n3 AB12345     USA  USA-2   id-3 35.39604   F\n4 AB12345     RUS  RUS-1   id-4 30.54711   F\n5 AB12345     CHN CHN-11   id-5 33.16138   M\n6 AB12345     RUS  RUS-2   id-6 47.65321   F\n\n\nExplore individual dataset: the approach is similar to an ordinary dataframe. For exmaple, to get the column names, can use this syntax:\n\nnames(data[['ADSL']]) # colnames() will also work\n\n [1] \"STUDYID\"  \"COUNTRY\"  \"SITEID\"   \"SUBJID\"   \"AGE\"      \"SEX\"     \n [7] \"ARMCD\"    \"ARM\"      \"ACTARMCD\" \"ACTARM\"   \"RACE\"     \"TRTSDTM\" \n[13] \"TRTEDTM\"  \"EOSDY\"    \"EOSDT\"    \"STRATA1\"  \"STRATA2\"  \"BMRKR1\"  \n[19] \"BMRKR2\"   \"REGION1\"  \"SAFFL\"    \"USUBJID\"  \"EOSSTT\"   \"EOTSTT\"  \n[25] \"DCSREAS\"  \"DTHDT\"   \n\n\n\n\nReproducibility\nIn teal_data, you can also include code that has produced the object. However, you still need to run the code outside this object!\n\ndata &lt;- teal_data(\n  ADSL = ADSL,\n  ADAE = ADAE,\n  code = '\n  path &lt;- \"data/cdisc\"\n  ADSL &lt;- read.csv(file.path(path, \"adsl.csv\"))\n  ADAE &lt;- read.csv(file.path(path, \"adae.csv\"))\n  '\n)\nget_code(data)\n\n[1] \"\\n  path &lt;- \\\"data/cdisc\\\"\\n  ADSL &lt;- read.csv(file.path(path, \\\"adsl.csv\\\"))\\n  ADAE &lt;- read.csv(file.path(path, \\\"adae.csv\\\"))\\n  \"\n\n\n\n\nJoin keys for CDISC data\n\n\njoin_keys(data)\n\nAn empty join_keys object. \n\n\nThere is no relationship between these two datasets, hence the filtering does not affect one another.\nMore on join_keys()\nSet up primary and foreign keys\n\ndefault_cdisc_join_keys[c(\"ADSL\", \"ADAE\")] # Subset for ADSL and ADAE\n\nA join_keys object containing foreign keys between 2 datasets:\nADSL: [STUDYID, USUBJID]\n  &lt;-- ADAE: [STUDYID, USUBJID]\nADAE: [STUDYID, USUBJID, ASTDTM, AETERM, AESEQ]\n  --&gt; ADSL: [STUDYID, USUBJID] \n\n\nInstead of using teal_data(), cdisc_data() automatcially sets the key.\n\ndata &lt;- cdisc_data(\n  ADSL = ADSL,\n  ADAE = ADAE\n)\n# check join_keys again\njoin_keys(data)\n\nA join_keys object containing foreign keys between 2 datasets:\nADSL: [STUDYID, USUBJID]\n  &lt;-- ADAE: [STUDYID, USUBJID]\nADAE: [STUDYID, USUBJID, ASTDTM, AETERM, AESEQ]\n  --&gt; ADSL: [STUDYID, USUBJID] \n\n\n\n\n\nProcess data: within()\n\ndata &lt;- teal_data() |&gt;\n  within({\n    path &lt;- \"data/cdisc\"\n    ADSL &lt;- read.csv(file.path(path, \"adsl.csv\"))\n    ADAE &lt;- read.csv(file.path(path, \"adae.csv\"))\n  })\ndata\n\nâœ…ï¸Ž code verified\n&lt;environment: 0x12f27cb00&gt; ðŸ”’ \nParent: &lt;environment: package:teal.modules.clinical&gt; \nBindings:\n- ADAE: [data.frame]\n- ADSL: [data.frame]\n- path: [character]\n\n\nNote that there are three binding rather than two. You can access the data in the same way ([[]] or $).\n\ndata$path\n\n[1] \"data/cdisc\"\n\n\nRead from another R script:\nCreate a separate script (preprocess.R) with the code where you read in the data, then source it.\n\ndata &lt;- teal_data() |&gt;\n  within(code, code = parse(text = readLines(\"demo_script/preprocess.R\")))\ndata\n\nâœ…ï¸Ž code verified\n&lt;environment: 0x10f963660&gt; ðŸ”’ \nParent: &lt;environment: package:teal.modules.clinical&gt; \nBindings:\n- ADAE: [data.frame]\n- ADSL: [data.frame]\n- path: [character]\n\n\n\n\njoin_keys() revisited\nDistinguish join_key and join_keys!\nAssign join_keys() with default cdisc keys"
  },
  {
    "objectID": "nest/teal_workshop.html#teal_slices",
    "href": "nest/teal_workshop.html#teal_slices",
    "title": "Teal workshop preparation",
    "section": "teal_slices",
    "text": "teal_slices\nSmaller topic, 6 pages"
  },
  {
    "objectID": "nest/teal_workshop.html#working-with-data",
    "href": "nest/teal_workshop.html#working-with-data",
    "title": "Teal workshop preparation",
    "section": "Working with data",
    "text": "Working with data\nOutline\n\nWhat is teal_data\nWays to add data\n\ndirectly adding data object\nadd data with within() (pipe needs to be introduced)\n\ncode inside\nsource from another script\n\n\nInteract with teal_data object\n\nextract object ([[]], $)\nexamine column names\n\nReproducibility\njoin_keys()\n\n\nGeneral usage\nWhat is teal_data?\n\nempty_teal_data &lt;- teal_data()\nclass(empty_teal_data)\n\n[1] \"teal_data\"\nattr(,\"package\")\n[1] \"teal.data\"\n\n\nGeneral usage\n\npath &lt;- 'data/cdisc/'\nADSL &lt;- read.csv(file.path(path, 'adsl.csv'))\n# create teal_data object\ndata &lt;- teal_data(\n  ADSL = ADSL\n)\n# return data object\ndata\n\nâœ– code unverified\n&lt;environment: 0x12a1fc820&gt; ðŸ”’ \nParent: &lt;environment: package:teal.modules.clinical&gt; \nBindings:\n- ADSL: [data.frame]\n\n\nAdd another dataset, for example, ADAE\n\nADAE &lt;- read.csv(file.path(path, 'adae.csv'))\n# update teal_data object\ndata &lt;- teal_data(\n  ADSL = ADSL,\n  ADAE = ADAE\n)\ndata\n\nâœ– code unverified\n&lt;environment: 0x129d5acb8&gt; ðŸ”’ \nParent: &lt;environment: package:teal.modules.clinical&gt; \nBindings:\n- ADAE: [data.frame]\n- ADSL: [data.frame]\n\n\n\n\nInteracting with the object\n\nnames(data)\n\n[1] \"ADAE\" \"ADSL\"\n\n\nExtract one dataset, can use either [[]] or $\n\ndata$ADSL[1:6,1:6] # only print the first 6 rows and 6 columns\n\n  STUDYID COUNTRY SITEID SUBJID      AGE SEX\n1 AB12345     CHN  CHN-1   id-1 36.94418   M\n2 AB12345     CHN CHN-11   id-2 39.82057   F\n3 AB12345     USA  USA-2   id-3 35.39604   F\n4 AB12345     RUS  RUS-1   id-4 30.54711   F\n5 AB12345     CHN CHN-11   id-5 33.16138   M\n6 AB12345     RUS  RUS-2   id-6 47.65321   F\n\ndata[['ADSL']][1:6,1:6]  # need quotation!\n\n  STUDYID COUNTRY SITEID SUBJID      AGE SEX\n1 AB12345     CHN  CHN-1   id-1 36.94418   M\n2 AB12345     CHN CHN-11   id-2 39.82057   F\n3 AB12345     USA  USA-2   id-3 35.39604   F\n4 AB12345     RUS  RUS-1   id-4 30.54711   F\n5 AB12345     CHN CHN-11   id-5 33.16138   M\n6 AB12345     RUS  RUS-2   id-6 47.65321   F\n\n\nExplore individual dataset: the approach is similar to an ordinary dataframe. For exmaple, to get the column names, can use this syntax:\n\nnames(data[['ADSL']]) # colnames() will also work\n\n [1] \"STUDYID\"  \"COUNTRY\"  \"SITEID\"   \"SUBJID\"   \"AGE\"      \"SEX\"     \n [7] \"ARMCD\"    \"ARM\"      \"ACTARMCD\" \"ACTARM\"   \"RACE\"     \"TRTSDTM\" \n[13] \"TRTEDTM\"  \"EOSDY\"    \"EOSDT\"    \"STRATA1\"  \"STRATA2\"  \"BMRKR1\"  \n[19] \"BMRKR2\"   \"REGION1\"  \"SAFFL\"    \"USUBJID\"  \"EOSSTT\"   \"EOTSTT\"  \n[25] \"DCSREAS\"  \"DTHDT\"   \n\n\n\n\nReproducibility\nIn teal_data, you can also include code that has produced the object. However, you still need to run the code outside this object!\n\ndata &lt;- teal_data(\n  ADSL = ADSL,\n  ADAE = ADAE,\n  code = '\n  path &lt;- \"data/cdisc\"\n  ADSL &lt;- read.csv(file.path(path, \"adsl.csv\"))\n  ADAE &lt;- read.csv(file.path(path, \"adae.csv\"))\n  '\n)\nget_code(data)\n\n[1] \"\\n  path &lt;- \\\"data/cdisc\\\"\\n  ADSL &lt;- read.csv(file.path(path, \\\"adsl.csv\\\"))\\n  ADAE &lt;- read.csv(file.path(path, \\\"adae.csv\\\"))\\n  \"\n\n\n\n\nJoin keys for CDISC data\n\n\njoin_keys(data)\n\nAn empty join_keys object. \n\n\nThere is no relationship between these two datasets, hence the filtering does not affect one another.\nMore on join_keys()\nSet up primary and foreign keys\n\ndefault_cdisc_join_keys[c(\"ADSL\", \"ADAE\")] # Subset for ADSL and ADAE\n\nA join_keys object containing foreign keys between 2 datasets:\nADSL: [STUDYID, USUBJID]\n  &lt;-- ADAE: [STUDYID, USUBJID]\nADAE: [STUDYID, USUBJID, ASTDTM, AETERM, AESEQ]\n  --&gt; ADSL: [STUDYID, USUBJID] \n\n\nInstead of using teal_data(), cdisc_data() automatcially sets the key.\n\ndata &lt;- cdisc_data(\n  ADSL = ADSL,\n  ADAE = ADAE\n)\n# check join_keys again\njoin_keys(data)\n\nA join_keys object containing foreign keys between 2 datasets:\nADSL: [STUDYID, USUBJID]\n  &lt;-- ADAE: [STUDYID, USUBJID]\nADAE: [STUDYID, USUBJID, ASTDTM, AETERM, AESEQ]\n  --&gt; ADSL: [STUDYID, USUBJID] \n\n\n\n\n\nProcess data: within()\n\ndata &lt;- teal_data() |&gt;\n  within({\n    path &lt;- \"data/cdisc\"\n    ADSL &lt;- read.csv(file.path(path, \"adsl.csv\"))\n    ADAE &lt;- read.csv(file.path(path, \"adae.csv\"))\n  })\ndata\n\nâœ…ï¸Ž code verified\n&lt;environment: 0x13857ba18&gt; ðŸ”’ \nParent: &lt;environment: package:teal.modules.clinical&gt; \nBindings:\n- ADAE: [data.frame]\n- ADSL: [data.frame]\n- path: [character]\n\n\nNote that there are three binding rather than two. You can access the data in the same way ([[]] or $).\n\ndata$path\n\n[1] \"data/cdisc\"\n\n\nRead from another R script:\nCreate a separate script (preprocess.R) with the code where you read in the data, then source it.\n\ndata &lt;- teal_data() |&gt;\n  within(code, code = parse(text = readLines(\"demo_script/preprocess.R\")))\ndata\n\nâœ…ï¸Ž code verified\n&lt;environment: 0x139b4a2e8&gt; ðŸ”’ \nParent: &lt;environment: package:teal.modules.clinical&gt; \nBindings:\n- ADAE: [data.frame]\n- ADSL: [data.frame]\n- path: [character]\n\n\n\n\njoin_keys() revisited\nDistinguish join_key and join_keys!\nAssign join_keys() with default cdisc keys"
  },
  {
    "objectID": "nest/teal_workshop.html#filters",
    "href": "nest/teal_workshop.html#filters",
    "title": "Teal workshop preparation",
    "section": "Filters",
    "text": "Filters\nTopics\n\nHow to set a filter\nDifference between different filters (anchored, fixed, custom expressions)\nUse for id\nModule specific filters\n\nResources\n\nTeal documentation: filter panel\n\nDifference between teal_slice and teal_slices: the former is in teal.slices package, while the later is in teal package - as a function to wrap individual ts objects.\nBy default, init() initializes the fitler panel without any active filters. User can add filter on any column.\nTo start an app with predefined filters, one must specify the filter argument, wrapped around teal_slices(). Example:\n\napp &lt;- init(\n  data = teal_data(IRIS = iris, CARS = mtcars),\n  modules = example_module(),\n  filter = teal_slices(\n    teal_slice(dataname = \"IRIS\", varname = \"Sepal.Length\"),\n    teal_slice(dataname = \"IRIS\", varname = \"Species\", selected = \"setosa\"),\n    teal_slice(dataname = \"CARS\", varname = \"mpg\", selected = c(20, Inf)),\n    teal_slice(dataname = \"CARS\", expr = \"qsec &lt; 20\", title = \"1/4 mile under 20 sec\", id = \"qsec_20\")\n  )\n)\n\nA few things to notice here in the filter panel:\n\nyou can create multiple filters on each dataset. You need to link the filter with the data name inside the teal_data object.\nRequired arguments are dataname and varname (if you are not using custom expression).\nFor selected argument, if you donâ€™t specify anything, the default will be the entire range. Distinguish between continuous variable and discrete.\n\n\n\n\nFixed, anchored and custom expressions\n\nf1 &lt;- teal_slice(\n  dataname = 'IRIS',\n  varname = 'Sepal.Length',\n  selected = 'setosa'\n)\nf1\n\n{\n  \"dataname\" : \"IRIS\",\n  \"varname\"  : \"Sepal.Length\",\n  \"id\"       : \"IRIS Sepal.Length\",\n  \"selected\" : [\"setosa\"],\n  \"fixed\"    : false,\n  \"anchored\" : false,\n  \"multiple\" : true\n}\n\n\n\nFixed: forbid settings state\nanchored: forbid removing and inactivating\n\nIf using custom expressions, must have id. Otherwise id is automatically set to be dataname - varname.\nThis expression must be a valid R expression which can be evaluated in the dataset.\n\n\nModule specific filters"
  },
  {
    "objectID": "nest/flowchart.html",
    "href": "nest/flowchart.html",
    "title": "Teal workflow",
    "section": "",
    "text": "this is the one\n\n\n\n\n\nflowchart LR\n    A[(DCH)]:::blue --&gt; B[eCRF data]:::orange --&gt; C[Data processing & automation]:::green --&gt; D[(Harbour)]:::blue\n    \n    classDef blue fill:#2a9df4,stroke:#1565c0,color:#000\n    classDef green fill:#72bf6a,stroke:#2e7d32,color:#000\n    classDef orange fill:#ee9f27,stroke:#e65100,color:#000\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n    A[(Harbour)]:::blue --&gt; B[\"**Create teal app** &lt;br/&gt;â€¢ teal.modules.mdr R package &lt;br/&gt;â€¢ teal for MDR handbook &lt;br/&gt;â€¢ Catalog templates\"]:::pink --&gt; C[Deploy - Posit Connect]:::blue2 \n    \n    classDef blue fill:#6ac5fe,stroke:#1565c0,color:#000\n    classDef pink fill:#ecbdc4,stroke:#e34234,color:#000\n    classDef blue2 fill:#caf0f8,stroke:#0077b6,color:#000\n\n\n\n\n\n\n\n\n\n\n\nclassDiagram\n    class Animal {\n        +String name\n        +eat()\n    }\n    class Dog {\n        +bark()\n    }\n    Animal &lt;|-- Dog\n\n\n\n\n\n\n\n\n\n\n\nflowchart TD\n    A[Rectangle]\n    B(Round edges)\n    C((Circle))\n    D{Diamond}\n    E{{Hexagon}}\n    F[/Parallelogram/]\n    G[\\Parallelogram alt\\]\n    H(/Stadium\\)\n    I[[Subroutine]]\n    J[(Database/Cylinder)]\n    K&gt;Flag]\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n    A[(Database)] --&gt; B[fa:fa-file Single File]\n    A --&gt; C[fa:fa-files-o Multiple Files]\n    C --&gt; D[fa:fa-folder Folder]\n    D --&gt; E[fa:fa-cloud-upload Upload]\n\n\n\n\n\n\n\n\n\n\n\nflowchart TD\n    A[\"Step 1:&lt;br/&gt;â€¢ Task A&lt;br/&gt;â€¢ Task B\"] --&gt; B[Step 2]\n\n\n\n\n\n\n\n\n\n\n\nflowchart TD\n    A[Main Process] --&gt; B[Item 1]\n    A --&gt; C[Item 2]\n    A --&gt; D[Item 3]\n    B --&gt; E[Next Step]\n    C --&gt; E\n    D --&gt; E\n\n\n\n\n\n\n\n\n\n\n\nflowchart TD\n    A[fa:fa-layer-group Multiple Datasets] --&gt; B[Process]\n\n\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n  participant Alice\n  participant Bob\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n    John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts &lt;br/&gt;prevail!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!"
  },
  {
    "objectID": "nest/shiny_module_example.html",
    "href": "nest/shiny_module_example.html",
    "title": "Shiny module example",
    "section": "",
    "text": "This is a basic shiny app."
  },
  {
    "objectID": "nest/shiny_module_example.html#app-without-modules",
    "href": "nest/shiny_module_example.html#app-without-modules",
    "title": "Shiny module example",
    "section": "App without modules",
    "text": "App without modules\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n#| components: [editor, viewer]\n#| layout: vertical\nlibrary(shiny)\ndata &lt;- iris\n\n# define ui\nui &lt;- fluidPage(\n  # Application title\n  titlePanel(\"Data display\"),\n  # Sidebar layout with input and output definitions\n  sidebarLayout(\n    # Sidebar panel for inputs (for now empty)\n    sidebarPanel(\n      # Add some placeholder controls here if needed\n      h4(\"Controls\")\n    ),\n\n    # Main panel for displaying outputs\n    mainPanel(\n      tableOutput(\"data_table\")\n    )\n  )\n)\n\n# Define server logic\nserver &lt;- function(input, output) {\n  output$data_table &lt;- renderTable({\n    data\n  })\n}\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "nest/shiny_module_example.html#make-the-same-app-with-modules",
    "href": "nest/shiny_module_example.html#make-the-same-app-with-modules",
    "title": "Shiny module example",
    "section": "Make the same app with modules",
    "text": "Make the same app with modules\n\nModule UI\n\nui &lt;- fluidPage(\n  titlePanel(\"Data display\"),\n  sidebarLayout(\n    sidebarPanel(\n      h4(\"Controls\")\n    ),\n    mainPanel(\n1      tableOutput(\"data_table\")\n    )\n  )\n)\n\n\n1\n\nWe are going to replace this line with a module UI function\n\n\n\n\nMake a function just for the table UI.\n\ntable_UI &lt;- function(id) {\n  ns &lt;- NS(id) # remember to have this NS\n  tableOutput(ns(\"data_table\"))\n}\n\n\n\nModule server\nHow it looks like without modules\n\nserver &lt;- function(input, output) {\n  output$data_table &lt;- renderTable({\n    data\n  })\n}\n\nMake a function, table_server.\n\ntable_server &lt;- function(id) {\n1  moduleServer(id, function(input, output, session) {\n2    data &lt;- reactive(data)\n    output$data_table &lt;- renderTable(\n3      data()\n    )\n  })\n}\n\n\n1\n\nmoduleServer is used to define the server logic for a module.\n\n2\n\nWrap data in reactive() to make it reactive.\n\n3\n\nUse data() to access the reactive value. It has to be a function call."
  },
  {
    "objectID": "nest/shiny_module_example.html#main-app-put-together",
    "href": "nest/shiny_module_example.html#main-app-put-together",
    "title": "Shiny module example",
    "section": "Main app: put together",
    "text": "Main app: put together\nNow this UI part looks very similar to the original one, except we replace tableOutput with table_UI.\n\nui &lt;- fluidPage(\n  titlePanel(\"Data display\"),\n  sidebarLayout(\n    sidebarPanel(\n1      h4(\"Controls\")\n    ),\n\n    mainPanel(\n2      table_UI(\"my_first_table\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n3  table_server(\"my_first_table\")\n}\n\nshinyApp(ui = ui, server = server)\n\n\n1\n\nPlaceholder for controls.\n\n2\n\nThe ID needs to match between ui and server. Also, it is possible to have multiple instances of the same module with different IDs.\n\n3\n\nThe ID needs to match between ui and server."
  },
  {
    "objectID": "nest/plotly.html",
    "href": "nest/plotly.html",
    "title": "Use teal with plotly",
    "section": "",
    "text": "This article demonstrates how to create interactive modules in teal using plotly."
  },
  {
    "objectID": "nest/plotly.html#how-scatterplotly-creates-a-shiny-app",
    "href": "nest/plotly.html#how-scatterplotly-creates-a-shiny-app",
    "title": "Use teal with plotly",
    "section": "How scatterplotly() creates a shiny app",
    "text": "How scatterplotly() creates a shiny app\nThe flow:\n\nUser calls tm_mdr_scatterplot_simple() â†’ creates a teal module\nModule defines UI (ui_mdr_scatterplot_simple) and Server (srv_mdr_scatterplot_simple)\nServer reactive calls scatterplotly() â†’ generates code expression\nteal::within() evaluates the code expression in data environment\nResult contains plot object ($p) which is rendered by Shiny\n\n\n\n\n\n\n\nReactive flow diagram\n\n\n\nUser changes color in color picker -&gt; Color picker module updates reactive colors -&gt; scatterplotly() is called with new colors -&gt; teal::within() re-evaluates the code with new colors -&gt; New plot object is created -&gt; Plot is re-rendered in the UI\n\n\n\nStep 0: scatterplotly function\nThis function creates a scatter plot using plotly based on the provided data and parameters.\n\n\nStep 1: module creation\nUser calls tm_mdr_scatterplot_simple() to create a teal module. This creates:\n\nUI function\nServer function\nServer arguments\n\n\ntm_mdr_scatterplot_simple(\n  label = \"Simple Scatter Plot\",\n  plot_dataname = \"tumor_response_longitudinal\",\n  subject_var = \"subject_id\",\n  x_var = \"time_week\",\n  y_var = \"tumor_size\",\n  color_var = \"treatment\"\n)\n\n\n\nStep 2: UI definition\n\nui_mdr_scatterplot_simple &lt;- function(id) {\n  ns &lt;- NS(id)  # Create namespace for this module instance\n  \n  bslib::page_fluid(\n    shinyjs::useShinyjs(),\n    tags$div(\n      trigger_tooltips_deps(),\n      \n      # Color picker UI component\n      tags$div(\n        style = \"margin-bottom: 15px;\",\n        tags$strong(\"Color Settings: \"),\n        colour_picker_ui(ns(\"colors\"))  # â† Color picker module\n      ),\n      \n      # Plot output\n      bslib::card(\n        full_screen = TRUE,\n        plotly::plotlyOutput(ns(\"scatter_plot\"), height = \"100%\")  # â† Plot output\n      )\n    )\n  )\n}\n\nKey points:\n\nns(\"scatter_plot\") creates a namespaced ID\nthis ID is used in the server to render the plot\n\n\n\nStep 3: server\n\nsrv_mdr_scatterplot_simple &lt;- function(\n  id,\n  data,              # â† Reactive teal_data object\n  plot_dataname,     # â† \"tumor_response_longitudinal\"\n  subject_var,       # â† \"subject_id\"\n  x_var,             # â† \"time_week\"\n  y_var,             # â† \"tumor_size\"\n  tooltip_vars,      # â† NULL or character vector\n  color_var,         # â† \"treatment\"\n  point_colors,      # â† Named color vector\n  filter_panel_api\n) {\n  moduleServer(id, function(input, output, session) {\n    ns &lt;- session$ns\n    \n    # ------------------------------------------------------------------------\n    # PART A: Color Picker Server\n    # ------------------------------------------------------------------------\n    \n1    color_inputs &lt;- colour_picker_srv(\n      \"colors\",\n      x = reactive({\n        # Extract color variable values from data\n        data()[[plot_dataname]][[color_var]]\n      }),\n      default_colors = point_colors\n    )\n    \n    # ------------------------------------------------------------------------\n    # PART B: Generate Plot Code (where scatterplotly() is called)\n    # ------------------------------------------------------------------------\n    \n    scatter_q &lt;- reactive({\n      req(color_inputs())  # Wait for colors to be ready\n      \n      data() |&gt;\n        within(\n          code,  # â† Name of the code expression in the result\n          code = scatterplotly(  # â† Call scatterplotly() to generate code\n            df = plot_dataname,           # \"tumor_response_longitudinal\"\n            x_var = x_var,               # \"time_week\"\n            y_var = y_var,               # \"tumor_size\"\n            color_var = color_var,       # \"treatment\"\n            id_var = subject_var,        # \"subject_id\"\n            colors = color_inputs(),      # Reactive colors from color picker\n            source = session$ns(\"scatterplot\"),  # \"module-scatterplot\"\n            tooltip_vars = tooltip_vars\n          )\n        )\n2    })\n    \n    # ------------------------------------------------------------------------\n    # PART C: Render the Plot\n    # ------------------------------------------------------------------------\n    \n    output$scatter_plot &lt;- plotly::renderPlotly({\n      scatter_q()$p |&gt;  # Extract the plot object from the result\n        setup_trigger_tooltips(session$ns(\"scatter_plot\"))\n3    })\n  })\n}\n\n\n1\n\ncolor_inputs() is a reactive that returns a named vector of colors. Example: c(\"Active\" = \"#1f77b4\", \"Placebo\" = \"#ff7f0e\")\n\n2\n\nscatterplotly() uses substitute() to create a code expression. teal::within() evaluates that code expression in the data() environment. The result is a list with $code (the expression) and $p (the plot object)\n\n3\n\nThis reactive: re-runs whenever scatter_q() changes (e.g., colors change). Extracts the $p component (the plotly plot object) Sets up tooltip triggers. Renders it in the UI\n\n\n\n\n\n\n\n\n\n\nHow teal::within() evaluates the code\n\n\n\n\n\nteal::within() takes a teal_data object and a code expression (from scatterplotly()), and evaluates the code in the context of the data environment.\n\ndata() |&gt;\n  within(\n    code,\n    code = scatterplotly(...)\n  )\n\n\n\n\nIt returns a list with\n\n$code; the original code expression (for reproducibility)\n$p; the generated plotly plot object"
  },
  {
    "objectID": "nest/plotly.html#select",
    "href": "nest/plotly.html#select",
    "title": "Use teal with plotly",
    "section": "Select",
    "text": "Select"
  },
  {
    "objectID": "nest/plotly_modules_2.html",
    "href": "nest/plotly_modules_2.html",
    "title": "plotly modules - part 2: selection events",
    "section": "",
    "text": "This document compares srv_mdr_scatterplot_simple (no events) with srv_mdr_scatterplot_table (with selection events) to show the pattern for adding interactive plotly selection functionality."
  },
  {
    "objectID": "nest/plotly_modules_1.html",
    "href": "nest/plotly_modules_1.html",
    "title": "plotly modules - part 1",
    "section": "",
    "text": "This article demonstrates how to create interactive modules in teal using plotly."
  },
  {
    "objectID": "nest/plotly_modules_1.html#how-scatterplotly-creates-a-shiny-app",
    "href": "nest/plotly_modules_1.html#how-scatterplotly-creates-a-shiny-app",
    "title": "plotly modules - part 1",
    "section": "How scatterplotly() creates a shiny app",
    "text": "How scatterplotly() creates a shiny app\nThe flow:\n\nUser calls tm_mdr_scatterplot_simple() â†’ creates a teal module\nModule defines UI (ui_mdr_scatterplot_simple) and Server (srv_mdr_scatterplot_simple)\nServer reactive calls scatterplotly() â†’ generates code expression\nteal::within() evaluates the code expression in data environment\nResult contains plot object ($p) which is rendered by Shiny\n\n\n\n\n\n\n\nReactive flow diagram\n\n\n\n\nUser changes color in color picker -&gt;\nColor picker module updates reactive colors -&gt;\nscatterplotly() is called with new colors -&gt;\nteal::within() re-evaluates the code with new colors -&gt;\nNew plot object is created -&gt;\nPlot is re-rendered in the UI\n\n\n\n\nStep 0: scatterplotly function\nThis function creates a scatter plot using plotly based on the provided data and parameters.\n\n\nStep 1: module creation\nUser calls tm_mdr_scatterplot_simple() to create a teal module. This creates:\n\nUI function\nServer function\nServer arguments\n\n\ntm_mdr_scatterplot_simple(\n  label = \"Simple Scatter Plot\",\n  plot_dataname = \"tumor_response_longitudinal\",\n  subject_var = \"subject_id\",\n  x_var = \"time_week\",\n  y_var = \"tumor_size\",\n  color_var = \"treatment\"\n)\n\n\n\nStep 2: UI definition\n\nui_mdr_scatterplot_simple &lt;- function(id) {\n  ns &lt;- NS(id)  # Create namespace for this module instance\n  \n  bslib::page_fluid(\n    shinyjs::useShinyjs(),\n    tags$div(\n      trigger_tooltips_deps(),\n      \n      # Color picker UI component\n      tags$div(\n        style = \"margin-bottom: 15px;\",\n        tags$strong(\"Color Settings: \"),\n        colour_picker_ui(ns(\"colors\"))  # â† Color picker module\n      ),\n      \n      # Plot output\n      bslib::card(\n        full_screen = TRUE,\n        plotly::plotlyOutput(ns(\"scatter_plot\"), height = \"100%\")  # â† Plot output\n      )\n    )\n  )\n}\n\nKey points:\n\nns(\"scatter_plot\") creates a namespaced ID\nthis ID is used in the server to render the plot\n\n\n\nStep 3: server\nServer reactive chain:\ncolor_inputs() â†’ scatter_q() â†’ output$scatter_plot\n\nsrv_mdr_scatterplot_simple &lt;- function(\n  id,\n  data,              # â† Reactive teal_data object\n  plot_dataname,     # â† \"tumor_response_longitudinal\"\n  subject_var,       # â† \"subject_id\"\n  x_var,             # â† \"time_week\"\n  y_var,             # â† \"tumor_size\"\n  tooltip_vars,      # â† NULL or character vector\n  color_var,         # â† \"treatment\"\n  point_colors,      # â† Named color vector\n  filter_panel_api\n) {\n  moduleServer(id, function(input, output, session) {\n    ns &lt;- session$ns\n    \n    # ------------------------------------------------------------------------\n    # PART A: Color Picker Server\n    # ------------------------------------------------------------------------\n    \n1    color_inputs &lt;- colour_picker_srv(\n      \"colors\",\n      x = reactive({\n        # Extract color variable values from data\n        data()[[plot_dataname]][[color_var]]\n      }),\n      default_colors = point_colors\n    )\n    \n    # ------------------------------------------------------------------------\n    # PART B: Generate Plot Code (where scatterplotly() is called)\n    # ------------------------------------------------------------------------\n    \n    scatter_q &lt;- reactive({\n      req(color_inputs())  # Wait for colors to be ready\n      \n      data() |&gt;\n        within(\n          code,  # â† Name of the code expression in the result\n          code = scatterplotly(  # â† Call scatterplotly() to generate code\n            df = plot_dataname,           # \"tumor_response_longitudinal\"\n            x_var = x_var,               # \"time_week\"\n            y_var = y_var,               # \"tumor_size\"\n            color_var = color_var,       # \"treatment\"\n            id_var = subject_var,        # \"subject_id\"\n            colors = color_inputs(),      # Reactive colors from color picker\n            source = session$ns(\"scatterplot\"),  # \"module-scatterplot\"\n            tooltip_vars = tooltip_vars\n          )\n        )\n2    })\n    \n    # ------------------------------------------------------------------------\n    # PART C: Render the Plot\n    # ------------------------------------------------------------------------\n    \n    output$scatter_plot &lt;- plotly::renderPlotly({\n      scatter_q()$p |&gt;  # Extract the plot object from the result\n        setup_trigger_tooltips(session$ns(\"scatter_plot\"))\n3    })\n  })\n}\n\n\n1\n\ncolor_inputs() is a reactive that returns a named vector of colors. Example: c(\"Active\" = \"#1f77b4\", \"Placebo\" = \"#ff7f0e\")\n\n2\n\nscatterplotly() uses substitute() to create a code expression. teal::within() evaluates that code expression in the data() environment. The result is a list with $code (the expression) and $p (the plot object)\n\n3\n\nThis reactive: re-runs whenever scatter_q() changes (e.g., colors change). Extracts the $p component (the plotly plot object) Sets up tooltip triggers. Renders it in the UI\n\n\n\n\n\n\n\n\n\n\nHow teal::within() evaluates the code\n\n\n\n\n\nteal::within() takes a teal_data object and a code expression (from scatterplotly()), and evaluates the code in the context of the data environment.\n\ndata() |&gt;\n  within(\n    code,\n    code = scatterplotly(...)\n  )\n\n\n\n\nIt returns a list with\n\n$code; the original code expression (for reproducibility)\n$p; the generated plotly plot object\n\n\n\nKey takeaways\n\nCode Generation Pattern:\n\nscatterplotly() doesnâ€™t create the plot directly\nIt creates CODE that will create the plot\nThis code is evaluated later by teal::within()\n\nWhy use substitute()?\n\nAllows code to reference data frames by name (as symbols)\nCode can be stored and reproduced later\nEnables tealâ€™s code reproducibility features\n\nReactive Chain:\n\ncolor_inputs() â†’ scatter_q() â†’ output$scatter_plot\nEach step depends on the previous one\nChanges cascade through the chain\n\nData Environment:\n\nteal::within() evaluates code in a special environment\nData frames are available by name (e.g., â€œtumor_response_longitudinalâ€)\nThis is why str2lang() converts strings to symbols\n\n\n\n\nComparison\nBenefits of code generation:\n\nCode can be saved and reproduced\nSupports tealâ€™s reproducibility features\nCode can be inspected and modified\nBetter for medical data review workflows\n\n\n# DIRECT APPROACH (what you might do in a regular Shiny app):\noutput$plot &lt;- renderPlotly({\n  plot_data &lt;- data()[[plot_dataname]]\n  plotly::plot_ly(plot_data, x = ~time_week, y = ~tumor_size, ...)\n})\n\n# CODE GENERATION APPROACH (what teal does):\noutput$plot &lt;- renderPlotly({\n  result &lt;- data() |&gt;\n    within(code, code = scatterplotly(...))\n  result$p\n})"
  },
  {
    "objectID": "nest/plotly_modules_1.html#summary",
    "href": "nest/plotly_modules_1.html#summary",
    "title": "plotly modules - part 1",
    "section": "Summary",
    "text": "Summary\n\nINITIAL SETUP:\n\nUser opens app\nUI renders with color picker and empty plot area\nServer initializes\n\nFIRST RENDER:\n\ncolor_inputs() returns default colors\nscatter_q() runs:\n\nCalls scatterplotly() with parameters\nscatterplotly() uses substitute() to create code expression\nteal::within() evaluates code in data environment\nReturns list(code = , p = )\n\noutput$scatter_plot renders the plot\n\nUSER INTERACTION:\n\nUser changes color in color picker\ncolor_inputs() reactive updates\nscatter_q() reactive detects change, re-runs\nNew plot generated with new colors\noutput$scatter_plot re-renders\n\nPLOT INTERACTION:\n\nUser selects points on plot (if dragmode = â€œselectâ€)\nplotly::event_register(â€œplotly_selectedâ€) captures selection\n(In other modules, this would trigger table filtering)"
  },
  {
    "objectID": "nest/plotly_modules_2.html#ui-differences",
    "href": "nest/plotly_modules_2.html#ui-differences",
    "title": "plotly modules - part 2: selection events",
    "section": "UI differences",
    "text": "UI differences\nThe change in UI is quite straight-forward. ui_t_reactables(ns(\"subtables\")) added to display tables.\n\n\nui_mdr_scatterplot_simple\nui_mdr_scatterplot_simple &lt;- function(id) {\n  ns &lt;- NS(id)\n  bslib::page_fluid(\n    shinyjs::useShinyjs(),\n    tags$div(\n      trigger_tooltips_deps(),\n      tags$div(\n        style = \"margin-bottom: 15px;\",\n        tags$strong(\"Color Settings: \"),\n        colour_picker_ui(ns(\"colors\"))\n      ),\n      bslib::card(\n        full_screen = TRUE,\n        plotly::plotlyOutput(ns(\"scatter_plot\"), height = \"100%\")\n      )\n      # â† NO tables UI here\n    )\n  )\n}\n\n\n\nui_mdr_scatterplot_table &lt;- function(id) {\n  ns &lt;- NS(id)\n  bslib::page_fluid(\n    shinyjs::useShinyjs(),\n    tags$div(\n      trigger_tooltips_deps(),\n      tags$div(\n        style = \"margin-bottom: 15px;\",\n        tags$strong(\"Color Settings: \"),\n        colour_picker_ui(ns(\"colors\"))\n      ),\n      bslib::card(\n        full_screen = TRUE,\n        plotly::plotlyOutput(ns(\"scatter_plot\"), height = \"100%\")\n      ),\n      tags$br(),\n      ui_t_reactables(ns(\"subtables\"))  # â† ADDED: Tables UI component\n    )\n  )\n}"
  },
  {
    "objectID": "nest/plotly_modules_2.html#server-differences",
    "href": "nest/plotly_modules_2.html#server-differences",
    "title": "plotly modules - part 2: selection events",
    "section": "Server differences",
    "text": "Server differences\n\nPart 1: color picker (same)\n\ncolor_inputs &lt;- colour_picker_srv(\n  \"colors\",\n  x = reactive({\n    data()[[plot_dataname]][[color_var]]\n  }),\n  default_colors = point_colors\n)\n\n\n\nPart 2: scatter plot generation with scatterplotly()\n\nscatter_q &lt;- reactive({\n  req(color_inputs())\n  data() |&gt;\n    within(\n      code,\n      code = scatterplotly(\n        df = plot_dataname,\n        x_var = x_var,\n        y_var = y_var,\n        color_var = color_var,\n        id_var = subject_var,\n        colors = color_inputs(),\n        source = session$ns(\"scatterplot\"),\n        tooltip_vars = tooltip_vars\n      )\n    )\n})\n\n\n\nPart 3: render plotly output with selection events handling\nKEY DIFFERENCE 1:\n\nSimple: No event registration\nTable: Registers \"plotly_selected\" event so Shiny can capture selections\n\n\n# SIMPLE VERSION:\noutput$scatter_plot &lt;- plotly::renderPlotly({\n  scatter_q()$p |&gt;\n    setup_trigger_tooltips(session$ns(\"scatter_plot\"))\n    # â† NO event_register() call\n})\n\n# TABLE VERSION:\noutput$scatter_plot &lt;- plotly::renderPlotly({\n  scatter_q()$p |&gt;\n    setup_trigger_tooltips(session$ns(\"scatter_plot\")) |&gt;\n    plotly::event_register(\"plotly_selected\")  # â† ADDED: Register selection event\n})\n\n\n\nPart 4: event data capture\nKEY DIFFERENCE 2:\n\nSimple: No event data capture, no reactive to read plotly selections\nTable: Uses plotly::event_data() to capture selection events reactively\n\n\nplotly_selected_scatter &lt;- reactive({\n  plotly::event_data(\"plotly_selected\", source = session$ns(\"scatterplot\"))\n})\n\nWhat plotly_selected_scatter() returns:\n\nNULL when nothing is selected\nA data frame with columns like:\n\ncustomdata: The row numbers of selected points\nx, y: Coordinates of selected points\ncurveNumber: Which trace the point belongs to\npointNumber: Index of the point in the trace\n\n\n\n\nPart 5: data filtering based on selection\nKEY DIFFERENCE 3:\n\nSimple: No data filtering, no tables to filter\nTable: Filters data based on selected points using:\n\nExtract customdata from plotly selection\nFind corresponding rows in plot_data\nGet subject_var values from selected rows\nFilter tables to only show those subjects\n\n\n\nfiltered_data_q &lt;- reactive({\n  req(plotly_selected_scatter())  # â† Wait for selection\n  scatter_selected &lt;- plotly_selected_scatter()\n\n  if (!is.null(scatter_selected)) {\n    # Extract selected values from plot data\n    selected_values &lt;- scatter_q()$plot_data |&gt;  # â† Access plot_data from scatter_q\n      dplyr::filter(customdata %in% scatter_selected$customdata)\n    \n    # Filter the actual data tables\n    data() |&gt;\n      within(\n        {\n          for (table_name in table_datanames) {\n            current_table &lt;- get(table_name)\n            filtered_table &lt;- current_table |&gt;\n              dplyr::filter(subject_var_sym %in% subject_var_selected)\n            assign(table_name, filtered_table)\n          }\n        },\n        table_datanames = table_datanames,\n        subject_var_sym = str2lang(subject_var),\n        subject_var_selected = selected_values[[subject_var]]  # â† Filter by subject\n      )\n  } else {\n    data()  # â† Return unfiltered data if no selection\n  }\n})\n\n\n\nPart 6: render tables based on filtered data\nKEY DIFFERENCE 4:\n\nSimple: No tables to render\nTable: Renders tables that automatically update when filtered_data_q() changes\n\n\nsrv_t_reactables(\n  \"subtables\",\n  data = filtered_data_q, # â† Use filtered data reactive\n  filter_panel_api = filter_panel_api,\n  datanames = table_datanames,\n  reactable_args = reactable_args\n)"
  },
  {
    "objectID": "nest/plotly_modules_2.html#flow-diagram",
    "href": "nest/plotly_modules_2.html#flow-diagram",
    "title": "plotly modules - part 2: selection events",
    "section": "Flow diagram",
    "text": "Flow diagram\nSIMPLE VERSION FLOW:\ncolor_inputs() â†’ scatter_q() â†’ output$scatter_plot\n(No event handling, no tables)\n\nTABLE VERSION FLOW:\ncolor_inputs() â†’ scatter_q() â†’ output$scatter_plot\n                                   â†“\n                         plotly_selected_scatter() â† User selects points\n                                   â†“\n                         filtered_data_q() â† Filter data based on selection\n                                   â†“\n                         srv_t_reactables() â† Update tables"
  },
  {
    "objectID": "nest/plotly_modules_2.html#key-pattern-to-add-selection-events",
    "href": "nest/plotly_modules_2.html#key-pattern-to-add-selection-events",
    "title": "plotly modules - part 2: selection events",
    "section": "Key pattern to add selection events",
    "text": "Key pattern to add selection events\n\nREGISTER THE EVENT in plot rendering\n\n\noutput$scatter_plot &lt;- plotly::renderPlotly({\n  scatter_q()$p |&gt;\n    setup_trigger_tooltips(session$ns(\"scatter_plot\")) |&gt;\n    plotly::event_register(\"plotly_selected\") # â† ADD THIS\n})\n\n\nCAPTURE THE EVENT DATA with a reactive\n\n\nplotly_selected_scatter &lt;- reactive({\n  plotly::event_data(\"plotly_selected\", source = session$ns(\"scatterplot\"))\n  # â† Source must match the source in scatterplotly() call\n})\n\n\nFILTER DATA based on selection\n\n\nfiltered_data_q &lt;- reactive({\n  req(plotly_selected_scatter())\n  scatter_selected &lt;- plotly_selected_scatter()\n\n  if (!is.null(scatter_selected)) {\n    # Extract selected subject IDs\n    selected_values &lt;- scatter_q()$plot_data |&gt;\n      dplyr::filter(customdata %in% scatter_selected$customdata)\n\n    # Filter your data tables\n    data() |&gt;\n      within({\n        # Filter logic here\n      })\n  } else {\n    data() # Return unfiltered if no selection\n  }\n})\n\n\nUSE FILTERED DATA in downstream components\n\n\nsrv_t_reactables(\n  \"subtables\",\n  data = filtered_data_q, # â† Use filtered data\n  ...\n)"
  },
  {
    "objectID": "nest/plotly_modules_2.html#key-takeaways",
    "href": "nest/plotly_modules_2.html#key-takeaways",
    "title": "plotly modules - part 2: selection events",
    "section": "Key takeaways",
    "text": "Key takeaways\n\nSOURCE IDENTIFIER:\n\nMust match between scatterplotly() and event_data()\nscatterplotly(â€¦, source = session$ns(â€œscatterplotâ€))\nevent_data(â€¦, source = session$ns(â€œscatterplotâ€))\nThese MUST match!\n\nCUSTOMDATA:\n\nscatterplotly() adds customdata = row_number() to each point\nThis is used to map selected points back to data rows\nAccess via: scatter_selected$customdata\n\nPLOT_DATA ACCESS:\n\nscatter_q()$plot_data contains the data used to create the plot\nThis includes the customdata column\nUse this to find which subjects correspond to selected points\nNOTE: plot_data is created inside scatterplotly() code but may need to be explicitly returned or accessed via teal::within() environment\nIf plot_data is not available, you may need to recreate it: plot_data &lt;- data()[[plot_dataname]] |&gt; dplyr::mutate(customdata = dplyr::row_number())\n\nREACTIVE DEPENDENCIES:\n\nfiltered_data_q() depends on plotly_selected_scatter()\nplotly_selected_scatter() depends on user interaction\nTables automatically update when filtered_data_q() changes\n\nNULL HANDLING:\n\nevent_data() returns NULL when nothing is selected\nAlways check for NULL before using selection data\nReturn unfiltered data when NULL (show all records)"
  },
  {
    "objectID": "nest/plotly_modules_2_events.html",
    "href": "nest/plotly_modules_2_events.html",
    "title": "plotly modules - part 2: selection events",
    "section": "",
    "text": "This document compares srv_mdr_scatterplot_simple (no events) with srv_mdr_scatterplot_table (with selection events) to show the pattern for adding interactive plotly selection functionality."
  },
  {
    "objectID": "nest/plotly_modules_2_events.html#ui-differences",
    "href": "nest/plotly_modules_2_events.html#ui-differences",
    "title": "plotly modules - part 2: selection events",
    "section": "UI differences",
    "text": "UI differences\nThe change in UI is quite straight-forward. ui_t_reactables(ns(\"subtables\")) added to display tables.\n\n\nui_mdr_scatterplot_simple\nui_mdr_scatterplot_simple &lt;- function(id) {\n  ns &lt;- NS(id)\n  bslib::page_fluid(\n    shinyjs::useShinyjs(),\n    tags$div(\n      trigger_tooltips_deps(),\n      tags$div(\n        style = \"margin-bottom: 15px;\",\n        tags$strong(\"Color Settings: \"),\n        colour_picker_ui(ns(\"colors\"))\n      ),\n      bslib::card(\n        full_screen = TRUE,\n        plotly::plotlyOutput(ns(\"scatter_plot\"), height = \"100%\")\n      )\n      # â† NO tables UI here\n    )\n  )\n}\n\n\n\nui_mdr_scatterplot_table &lt;- function(id) {\n  ns &lt;- NS(id)\n  bslib::page_fluid(\n    shinyjs::useShinyjs(),\n    tags$div(\n      trigger_tooltips_deps(),\n      tags$div(\n        style = \"margin-bottom: 15px;\",\n        tags$strong(\"Color Settings: \"),\n        colour_picker_ui(ns(\"colors\"))\n      ),\n      bslib::card(\n        full_screen = TRUE,\n        plotly::plotlyOutput(ns(\"scatter_plot\"), height = \"100%\")\n      ),\n      tags$br(),\n      ui_t_reactables(ns(\"subtables\"))  # â† ADDED: Tables UI component\n    )\n  )\n}"
  },
  {
    "objectID": "nest/plotly_modules_2_events.html#server-differences",
    "href": "nest/plotly_modules_2_events.html#server-differences",
    "title": "plotly modules - part 2: selection events",
    "section": "Server differences",
    "text": "Server differences\n\nPart 1: color picker (same)\n\ncolor_inputs &lt;- colour_picker_srv(\n  \"colors\",\n  x = reactive({\n    data()[[plot_dataname]][[color_var]]\n  }),\n  default_colors = point_colors\n)\n\n\n\nPart 2: scatter plot generation with scatterplotly()\n\nscatter_q &lt;- reactive({\n  req(color_inputs())\n  data() |&gt;\n    within(\n      code,\n      code = scatterplotly(\n        df = plot_dataname,\n        x_var = x_var,\n        y_var = y_var,\n        color_var = color_var,\n        id_var = subject_var,\n        colors = color_inputs(),\n        source = session$ns(\"scatterplot\"),\n        tooltip_vars = tooltip_vars\n      )\n    )\n})\n\n\n\nPart 3: render plotly output with selection events handling\nKEY DIFFERENCE 1:\n\nSimple: No event registration\nTable: Registers \"plotly_selected\" event so Shiny can capture selections\n\n\n# SIMPLE VERSION:\noutput$scatter_plot &lt;- plotly::renderPlotly({\n  scatter_q()$p |&gt;\n    setup_trigger_tooltips(session$ns(\"scatter_plot\"))\n    # â† NO event_register() call\n})\n\n# TABLE VERSION:\noutput$scatter_plot &lt;- plotly::renderPlotly({\n  scatter_q()$p |&gt;\n    setup_trigger_tooltips(session$ns(\"scatter_plot\")) |&gt;\n    plotly::event_register(\"plotly_selected\")  # â† ADDED: Register selection event\n})\n\n\n\nPart 4: event data capture\nKEY DIFFERENCE 2:\n\nSimple: No event data capture, no reactive to read plotly selections\nTable: Uses plotly::event_data() to capture selection events reactively\n\n\nplotly_selected_scatter &lt;- reactive({\n  plotly::event_data(\"plotly_selected\", source = session$ns(\"scatterplot\"))\n})\n\nWhat plotly_selected_scatter() returns:\n\nNULL when nothing is selected\nA data frame with columns like:\n\ncustomdata: The row numbers of selected points\nx, y: Coordinates of selected points\ncurveNumber: Which trace the point belongs to\npointNumber: Index of the point in the trace\n\n\n\n\nPart 5: data filtering based on selection\nKEY DIFFERENCE 3:\n\nSimple: No data filtering, no tables to filter\nTable: Filters data based on selected points using:\n\nExtract customdata from plotly selection\nFind corresponding rows in plot_data\nGet subject_var values from selected rows\nFilter tables to only show those subjects\n\n\n\nfiltered_data_q &lt;- reactive({\n  req(plotly_selected_scatter())  # â† Wait for selection\n  scatter_selected &lt;- plotly_selected_scatter()\n\n  if (!is.null(scatter_selected)) {\n    # Extract selected values from plot data\n    selected_values &lt;- scatter_q()$plot_data |&gt;  # â† Access plot_data from scatter_q\n      dplyr::filter(customdata %in% scatter_selected$customdata)\n    \n    # Filter the actual data tables\n    data() |&gt;\n      within(\n        {\n          for (table_name in table_datanames) {\n            current_table &lt;- get(table_name)\n            filtered_table &lt;- current_table |&gt;\n              dplyr::filter(subject_var_sym %in% subject_var_selected)\n            assign(table_name, filtered_table)\n          }\n        },\n        table_datanames = table_datanames,\n        subject_var_sym = str2lang(subject_var),\n        subject_var_selected = selected_values[[subject_var]]  # â† Filter by subject\n      )\n  } else {\n    data()  # â† Return unfiltered data if no selection\n  }\n})\n\n\n\nPart 6: render tables based on filtered data\nKEY DIFFERENCE 4:\n\nSimple: No tables to render\nTable: Renders tables that automatically update when filtered_data_q() changes\n\n\nsrv_t_reactables(\n  \"subtables\",\n  data = filtered_data_q, # â† Use filtered data reactive\n  filter_panel_api = filter_panel_api,\n  datanames = table_datanames,\n  reactable_args = reactable_args\n)"
  },
  {
    "objectID": "nest/plotly_modules_2_events.html#flow-diagram",
    "href": "nest/plotly_modules_2_events.html#flow-diagram",
    "title": "plotly modules - part 2: selection events",
    "section": "Flow diagram",
    "text": "Flow diagram\nSIMPLE VERSION FLOW:\ncolor_inputs() â†’ scatter_q() â†’ output$scatter_plot\n(No event handling, no tables)\n\nTABLE VERSION FLOW:\ncolor_inputs() â†’ scatter_q() â†’ output$scatter_plot\n                                   â†“\n                         plotly_selected_scatter() â† User selects points\n                                   â†“\n                         filtered_data_q() â† Filter data based on selection\n                                   â†“\n                         srv_t_reactables() â† Update tables"
  },
  {
    "objectID": "nest/plotly_modules_2_events.html#key-pattern-to-add-selection-events",
    "href": "nest/plotly_modules_2_events.html#key-pattern-to-add-selection-events",
    "title": "plotly modules - part 2: selection events",
    "section": "Key pattern to add selection events",
    "text": "Key pattern to add selection events\n\nREGISTER THE EVENT in plot rendering\n\n\noutput$scatter_plot &lt;- plotly::renderPlotly({\n  scatter_q()$p |&gt;\n    setup_trigger_tooltips(session$ns(\"scatter_plot\")) |&gt;\n    plotly::event_register(\"plotly_selected\") # â† ADD THIS\n})\n\n\nCAPTURE THE EVENT DATA with a reactive\n\n\nplotly_selected_scatter &lt;- reactive({\n  plotly::event_data(\"plotly_selected\", source = session$ns(\"scatterplot\"))\n  # â† Source must match the source in scatterplotly() call\n})\n\n\nFILTER DATA based on selection\n\n\nfiltered_data_q &lt;- reactive({\n  req(plotly_selected_scatter())\n  scatter_selected &lt;- plotly_selected_scatter()\n\n  if (!is.null(scatter_selected)) {\n    # Extract selected subject IDs\n    selected_values &lt;- scatter_q()$plot_data |&gt;\n      dplyr::filter(customdata %in% scatter_selected$customdata)\n\n    # Filter your data tables\n    data() |&gt;\n      within({\n        # Filter logic here\n      })\n  } else {\n    data() # Return unfiltered if no selection\n  }\n})\n\n\nUSE FILTERED DATA in downstream components\n\n\nsrv_t_reactables(\n  \"subtables\",\n  data = filtered_data_q, # â† Use filtered data\n  ...\n)"
  },
  {
    "objectID": "nest/plotly_modules_2_events.html#key-takeaways",
    "href": "nest/plotly_modules_2_events.html#key-takeaways",
    "title": "plotly modules - part 2: selection events",
    "section": "Key takeaways",
    "text": "Key takeaways\n\nSOURCE IDENTIFIER:\n\nMust match between scatterplotly() and event_data()\nscatterplotly(â€¦, source = session$ns(â€œscatterplotâ€))\nevent_data(â€¦, source = session$ns(â€œscatterplotâ€))\nThese MUST match!\n\nCUSTOMDATA:\n\nscatterplotly() adds customdata = row_number() to each point\nThis is used to map selected points back to data rows\nAccess via: scatter_selected$customdata\n\nPLOT_DATA ACCESS:\n\nscatter_q()$plot_data contains the data used to create the plot\nThis includes the customdata column\nUse this to find which subjects correspond to selected points\nNOTE: plot_data is created inside scatterplotly() code but may need to be explicitly returned or accessed via teal::within() environment\nIf plot_data is not available, you may need to recreate it: plot_data &lt;- data()[[plot_dataname]] |&gt; dplyr::mutate(customdata = dplyr::row_number())\n\nREACTIVE DEPENDENCIES:\n\nfiltered_data_q() depends on plotly_selected_scatter()\nplotly_selected_scatter() depends on user interaction\nTables automatically update when filtered_data_q() changes\n\nNULL HANDLING:\n\nevent_data() returns NULL when nothing is selected\nAlways check for NULL before using selection data\nReturn unfiltered data when NULL (show all records)"
  }
]